对“强 FIFO 基线”的定义是：顺序仍按入控制区 entry_rank 冻结不重排，但要做到在 seeds=1..5 上基本满足：

  - consistency_merge_order_mismatch_count ≈ 0（最好=0）
  - SUMO 日志里的 emergency braking 明显下降/最好为 0
  - check_plans 仍 gap_bad=0,target_mono_bad=0，且 collision_count=0

  要把你现在的 FIFO 升级到这个水平，我会按“先最小改动、再加兜底”的两段走：

  ## 1) 先把 FIFO 的 target 变成“物理可达”（不改 FIFO 语义）

  现状 FIFO 在入区时用 natural_eta = t + d_entry / vmax 冻结目标，这个太理想化，会导致“头车本来就到不了/到得很晚”，后车反而更容易先
  commit 进 :n_merge*，顺序就乱。

  改法（只改目标时间计算逻辑，顺序不变）：

  - 在车辆首次进入控制区时，计算 t_min（你 DP 已经在用同款公式）：
      - t_min = minimum_arrival_time_at_on_ramp(t_now, D_to_merge, v_now, a_max, v_max)
      - 其中 a_max 用 traci.vehicle.getAccel(veh_id)（和 DP 一致），v_max 用流的 main_vmax/ramp_vmax
  - 然后冻结：
      - target = max(t_min, last_target + fifo_gap_s)（第一辆用 max(t_min, t_now + fifo_gap_s)）

  这样做的目的很明确：FIFO 不再给出“理论上很早但实际根本到不了”的目标，从源头减少计划-执行撕裂。

  ## 2) 如果 mismatch 仍不为 0：加一个“只在最后几十米触发”的顺序兜底（强制不抢门）

  即便关掉了 SUMO 的让行裁判（speedMode=23），也不会自动保证“非头车不抢先进入冲突区”，因为它们可能已经物理上更靠前。要想保证“计划顺序
  =最终顺序”，必须在接近合流口时有个硬约束：非头车不能先进入 :n_merge*。

  兜底策略（只在极近距离触发，尽量不干扰整体）：

  - 在 ramp/policies/fifo/command_builder.py 里对每步命令加一条：
      - 取 head = plan.order[0]
      - 对 veh_id != head：如果 D_to_merge 已经小到“下一两步就会进 internal edge”的范围（比如 < 30~40m，这个阈值后面用 GUI+events/
        commands 定一下），则直接下发 v_cmd=0（或极低），把它挡在门口外
      - head 正常按 target 追踪即可

  这一步的意义：把“顺序”从软目标变成硬约束，才能把 mismatch 压到 0。

  ## 验证方式（你一看就知道是否达标）

  - 仍跑同一套矩阵 seeds=1..5 三策略
  - 对 FIFO 重点看：
      - consistency_merge_order_mismatch_count 是否从 11–13 掉到接近 0
      - cross_time_error_* 是否显著下降
      - *.log 里 emergency braking 是否显著下降
      - check_plans 仍全 0，collision_count=0

  如果你认可“强基线必须 mismatch≈0”，那我建议按上面顺序做：先做 1)（纯 target 修复），跑矩阵看效果；只有 mismatch 仍不干净，再加 2)
  的兜底门控。你确认一下：强基线的 mismatch 你要求硬阈值是 0 还是允许 <=1？